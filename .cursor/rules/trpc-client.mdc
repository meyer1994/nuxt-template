---
globs: app/**/*.vue,app/**/*.ts
---

# tRPC Client Usage Guide

Core patterns for using tRPC client methods in Vue components.

## Client Access

```vue
<script setup lang="ts">
const { $trpc } = useNuxtApp()
</script>
```

## Query Methods

### `.query()` - Direct API call

```vue
<script setup lang="ts">
const { $trpc } = useNuxtApp()

// Direct call (not reactive)
const handleClick = async () => {
  const result = await $trpc.process.list.query()
  console.log(result)
}
</script>
```

### `useQuery()` - Reactive queries

```vue
<script setup lang="ts">
const { $trpc } = useNuxtApp()

// Reactive query (auto-updates)
const { data, pending, error, refresh } = await $trpc.process.list.useQuery()

// With parameters
const processId = ref('uuid-here')
const { data: files } = await $trpc.files.list
  .useQuery(computed(() => ({ processId: processId.value })))
</script>
```

### `useAsyncData()` with `.query()`

```vue
<script setup lang="ts">
const { $trpc } = useNuxtApp()

// Server-side rendering + caching
const { data: processes, refresh } = await useAsyncData(
  'processes', // cache key
  () => $trpc.process.list.query()
)

// With parameters
const processId = 'uuid-here'
const { data: files } = await useAsyncData(
  `files-${processId}`,
  () => $trpc.files.list.query({ processId })
)

// Multiple parallel queries
const [
  { data: files, refresh: refreshFiles },
  { data: notes, refresh: refreshNotes },
] = [
  useAsyncData('files', () => $trpc.files.list.query({ processId })),
  useAsyncData('notes', () => $trpc.notes.list.query({ processId })),
]
</script>
```

## Mutation Methods

### `.mutate()` - Direct mutation call

```vue
<script setup lang="ts">
const { $trpc } = useNuxtApp()

const handleSubmit = async (formData) => {
  try {
    const result = await $trpc.process.create.mutate(formData)
    console.log('Created:', result)
  } catch (error) {
    console.error('Failed:', error)
  }
}

const handleDelete = async (id: string) => {
  await $trpc.process.delete.mutate({ id })
  await refresh() // Refresh related queries
}
</script>
```

### `useMutation()` - Reactive mutations

```vue
<script setup lang="ts">
const { $trpc } = useNuxtApp()

// Reactive mutation state
const { 
  mutate: createProcess, 
  data, 
  pending: isCreating, 
  error 
} = $trpc.process.create.useMutation()

const handleSubmit = async (formData) => {
  await createProcess(formData)
  if (!error.value) {
    console.log('Success:', data.value)
  }
}
</script>
```

### `useAsyncData()` with `.mutate()`

```vue
<script setup lang="ts">
const { $trpc } = useNuxtApp()

// For mutations that need caching/SSR
const { execute: deleteProcess, pending: isDeleting } = await useAsyncData(
  null, // no cache key for mutations
  () => $trpc.process.delete.mutate({ id: 'uuid' }),
  { immediate: false } // Don't run immediately
)

const handleDelete = async () => {
  await deleteProcess()
  await refresh() // Refresh other queries
}
</script>
```

## When to Use Each Method

| Method                       | Use Case                   | Features                                |
|------------------------------|----------------------------|-----------------------------------------|
| `.query()`                   | One-time data fetch        | Simple, direct call                     |
| `useQuery()`                 | Reactive data that updates | Auto-refresh, reactive                  |
| `useAsyncData() + .query()`  | SSR + caching              | Server-side rendering, cache management |
| `.mutate()`                  | Simple form submissions    | Direct mutation call                    |
| `useMutation()`              | Complex mutation state     | Loading states, error handling          |
| `useAsyncData() + .mutate()` | Cached mutations           | Rare, specific use cases                |

## Complete Example

```vue
<script setup lang="ts">
const { $trpc } = useNuxtApp()

// Query data with caching
const { data: processes, refresh } = await useAsyncData(
  'processes',
  () => $trpc.process.list.query()
)

// Reactive mutation
const { mutate: createProcess, pending: isCreating } = 
  $trpc.process.create.useMutation()

// Form submission
const handleSubmit = async (formData) => {
  await createProcess(formData)
  await refresh() // Refresh the list
}

// Direct delete
const handleDelete = async (id: string) => {
  await $trpc.process.delete.mutate({ id })
  await refresh()
}
</script>

<template>
  <div>
    <button @click="handleSubmit(data)" :disabled="isCreating">
      {{ isCreating ? 'Creating...' : 'Create' }}
    </button>
    
    <div v-for="process in processes" :key="process.id">
      {{ process.name }}
      <button @click="handleDelete(process.id)">Delete</button>
    </div>
  </div>
</template>
```